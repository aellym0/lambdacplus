<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Toplevel (lambdacplus.Lambdacplus.Toplevel)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">lambdacplus</a> &#x00BB; <a href="../index.html">Lambdacplus</a> &#x00BB; Toplevel</nav><h1>Module <code>Lambdacplus.Toplevel</code></h1></header><aside><p>This module glues all our modules into a single function, namely <a href="index.html#val-parse_and_eval"><code>parse_and_eval</code></a> which is responsible for parsing and evaluating strings input by users.</p></aside><dl><dt class="spec type" id="type-contexts"><a href="#type-contexts" class="anchor"></a><code><span class="keyword">type</span> contexts</code><code> = </code><code>{</code><table class="record"><tr id="type-contexts.naming_ctx" class="anchored"><td class="def field"><a href="#type-contexts.naming_ctx" class="anchor"></a><code>naming_ctx : <a href="../../Kernel/Context/index.html#type-t">Kernel.Context.t</a>;</code></td><td class="doc"><p>This is used to parse the string to the parser's AST and then convert it to the de bruijn one, where all variables are identified by de bruijn indices.</p></td></tr><tr id="type-contexts.eval_ctx" class="anchored"><td class="def field"><a href="#type-contexts.eval_ctx" class="anchor"></a><code>eval_ctx : <a href="../../Kernel/Context/index.html#type-t">Kernel.Context.t</a>;</code></td><td class="doc"><p>This is used for typechecking and evluating expressions in the de bruijn AST. All types and bindings stored here have indices for variable names, rather than strings.</p></td></tr></table><code>}</code></dt><dd><p>The current state of the naming and evaluation contexts.</p></dd></dl><dl><dt class="spec value" id="val-initial_contexts"><a href="#val-initial_contexts" class="anchor"></a><code><span class="keyword">val</span> initial_contexts : <a href="index.html#type-contexts">contexts</a></code></dt><dd><p>Initial (ie empty) naming and evaluation contexts.</p></dd></dl><dl><dt class="spec value" id="val-parse_and_eval"><a href="#val-parse_and_eval" class="anchor"></a><code><span class="keyword">val</span> parse_and_eval : string <span>&#45;&gt;</span> <a href="index.html#type-contexts">contexts</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-contexts">contexts</a> * string, string * <a href="../Error_reporting/index.html#type-err_loc">Error_reporting.err_loc</a>)</span> Stdlib.result</span></code></dt><dd><p><code>parse_and_eval str {naming_ctx; eval_ctx}</code> parses and evalutes a string.</p><p>Note that we actually use 2 contexts to parse and evaluate user inputs:</p><ul><li><a href="index.html#type-contexts.naming_ctx"><code>naming_ctx</code></a> is first used to parse the input string into the de bruijn AST.</li><li><a href="index.html#type-contexts.eval_ctx"><code>eval_ctx</code></a> is then used for typechecking and evaluating.</li></ul><p>The output is a <code>result</code> record (which is like an Either monad) that is either</p><ul><li><p><code>Ok {naming_ctx, eval_ctx}, result</code> where</p><ul><li><a href="index.html#type-contexts.naming_ctx"><code>naming_ctx</code></a> and <a href="index.html#type-contexts.eval_ctx"><code>eval_ctx</code></a> are the new naming and evaluation contexts respectively</li><li><code>result</code> is the string of the expression resulting from evaluating <code>str</code></li></ul></li></ul><ul><li><p><code>Error err_str, err_loc</code> where</p><ul><li><code>err_str</code> is a string representation of the error that occurred</li><li><code>err_loc</code> is a <a href="../Error_reporting/index.html#type-err_loc"><code>Error_reporting.err_loc</code></a>, ie a record containing the location of the error</li></ul></li></ul></dd></dl></div></body></html>