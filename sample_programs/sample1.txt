// Assume that T is a type and that P is some unary predicate.
constant T : Type
constant P : ∏ (_ : T), Prop

// Further assume that the predicate P holds for every x of type T.
// This behaves like a lambda abstraction that returns a proof of (P x) for
// any input x of type T.
axiom ax : ∀ (x : T), P x

// Now suppose y is an element of type T.
constant y : T

// hPy is a proof that (P y) holds.
def hPy := (ax y : P y)

// Let's try to normalize a funny looking expression.
eval let id := λ (T : Type) (x : T) => x in id (P y) hPy