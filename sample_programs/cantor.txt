// Formalization of Lawvere's fixed point theorem, which captures the essence of
// the diagonal argument as found in Cantor's famous theorem on cardinality.

constant X : Type
constant Y : Type

// Definition of equality.
constant eq : forall (X : Type) (x : X) (y : X), Prop

// Reflexivity of =
axiom eq_refl : forall (X : Type) (x : X), eq X x x

// Symmetry of =
axiom eq_symm : forall (X : Type) (x : X) (y : X), (eq X x y) -> (eq X y x)

// Transitivity of =
axiom eq_trans : 
    forall (X : Type) (x : X) (y : X) (z : X),
        (eq X x y) -> (eq X y z) -> (eq X x z)

// If 2 functions are equal f = g, then f x = g x for every x : X.
axiom congr_fun : 
  forall (f : X -> Y) (g : X -> Y),
    (eq (X -> Y) f g) -> (forall x : X, eq Y (f x) (g x))

// f has a fixed point if f x = x for some x : X.
def has_fixed_point :=
  fun (X : Type) (f : X -> X) => exists x : X, eq X (f x) x

// f is surjective
def surjective :=
  fun (X : Type) (Y : Type) (f : X -> Y) => forall y : Y, exists x : X, eq Y (f x) y

// Assume g : X -> X -> Y  is surjective and that f : Y -> Y is any function.
// We aim to show that f has a fixed point.
axiom h : exists g : X -> (X -> Y), surjective X (X -> Y) g
axiom f : Y -> Y

// Pull the existential apart.
def g := fst h
def g_surj := snd h

// Define the diagonal function.
def diag := fun (x : X) => f (g x x)

// Since g : X -> X -> Y, there must be some x : X with g x = diag
def h := (g_surj diag : exists x : X, eq (X -> Y) (g x) diag)

// Grab this witness and the proof that g x = diag
def x := fst h
def h := (snd h : eq (X -> Y) (g x) diag)

// Next we have some boring manipulations using the axioms of equality to
// establish that (g x x) = f (g x x) and then flip the equality around.

// Since (g x) and diag are equal as functions, g x x = diag x
def h1 := (congr_fun (g x) diag h x : eq Y (g x x) (diag x))

// diag x = f (g x x) must hold for this specific x we're working with because
// that's the definition of the diagonal function, diag.
def h2 := (eq_refl Y (diag x) : eq Y (diag x) (f (g x x)))

// By transitivity, g x x = f (g x x)
def h := (eq_trans Y (g x x) (diag x) (f (g x x)) h1 h2 : eq Y (g x x) (f (g x x)))

// Use symmetry to obtain f (g x x) = g x x
def h := (eq_symm Y (g x x) (f (g x x)) h : eq Y (f (g x x)) (g x x))

// Use (g x x) and h to witness the existentially quantified statement that f
// has a fixed point.
check ((g x x, h) : has_fixed_point Y f)