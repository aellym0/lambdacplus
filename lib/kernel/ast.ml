(* This is our internal AST, which is identical to the one generated by the
parser, except that variables are given by de bruijn indices.
*)

module Loc = Common.Location

type expr = raw_expr Loc.located
and raw_expr =
  | Type
  | Kind
  | Pi of {input_var : string;
           input_type : expr;
           output_type : expr}
  | Var of int (* This int is the de bruijn index of the variable. *)
  | Fun of {input_var : string;
            input_type : expr option;
            body : expr}
  | App of {fn : expr;
            arg : expr}
  | Ascription of {expr : expr;
                   expr_type : expr}
  | Let of {var_name : string; 
            binding : expr;
            body : expr}
[@@deriving show]

let located_kind = Loc.locate Kind

(* Check if 2 expressions are structurally equal. *)
let rec equal (expr1 : expr) (expr2 : expr) =
  match expr1.data, expr2.data with
  | Type, Type | Kind, Kind -> true

  | Var index1, Var index2 -> index1 = index2 
    (* print_endline @@ "Checking" ^ (string_of_int index1) ^ (string_of_int index2); *)

  | App {fn=fn1; arg=arg1}, App {fn=fn2; arg=arg2} ->
    equal fn1 fn2 && equal arg1 arg2

  | Pi {input_type=in1; output_type=out1; _},
    Pi {input_type=in2; output_type=out2; _} ->
    equal in1 in2 && equal out1 out2

  | Fun {body=body1; _}, Fun {body=body2; _} ->
    equal body1 body2

  | Let {binding=binding1; body=body1; _},
    Let {binding=binding2; body=body2; _} ->
      equal binding1 binding2 && equal body1 body2

  | _, _ -> assert false

let shift shift_by (expr : expr) =
  let rec shift_raw_expr cutoff raw_expr =
    match raw_expr with
    | Type | Kind -> raw_expr

    | Var index as var ->
      if index >= cutoff then Var (index + shift_by) else var

    | Pi {input_var; input_type; output_type} ->
      let input_type = shift_expr cutoff input_type in
      let output_type = shift_expr (cutoff + 1) output_type in
      Pi {input_var; input_type; output_type}

    | Fun {input_var; input_type; body} ->
      let input_type = CCOpt.map (shift_expr cutoff) input_type in
      let body = shift_expr (cutoff + 1) body in
      Fun {input_var; input_type; body}

    | App {fn; arg} ->
      let fn = shift_expr cutoff fn in
      let arg = shift_expr cutoff arg in
      App {fn; arg}

    | Ascription {expr; expr_type} ->
      let expr = shift_expr cutoff expr in
      let expr_type = shift_expr cutoff expr_type in
      Ascription {expr; expr_type}
    
    | Let {var_name; binding; body} ->
      let binding = shift_expr cutoff binding in
      let body = shift_expr (cutoff + 1) body in
      Let {var_name; binding; body}

  and shift_expr cutoff expr =
    Loc.update_data expr @@ shift_raw_expr cutoff

  in shift_expr 0 expr

type list_of_exprs = expr list
[@@deriving show]

type stmt = raw_stmt Loc.located
and raw_stmt =
  | Def of {var_name : string; binding : expr}
  | Axiom of {var_name : string; var_type : expr}
  | Check of expr
  | Eval of expr
[@@deriving show]

type list_of_stmts = stmt list
[@@deriving show]