(* This is our internal AST, which is identical to the one generated by the
parser, except that variables are given by de bruijn indices.
*)

module Loc = Common.Location

let always_true = fun _ _ -> true

type expr = raw_expr Loc.located
and raw_expr =
  | Type
  | Kind
  | Pi of {input_var : (string [@visitors.opaque] [@equal always_true]);
           input_type : expr;
           output_type : expr}
  | Var of (int [@visitors.opaque])
  | Fun of {input_var : (string [@visitors.opaque] [@equal always_true]);
            input_type : (expr option [@visitors.opaque]);
            body : expr}
  | App of {fn : expr;
            arg : expr}
  | Ascription of {expr : expr;
                   expr_type : expr}
  | Let of {var_name : (string [@visitors.opaque] [@equal always_true]);
            binding : expr;
            body : expr}
[@@deriving show, eq, 
  visitors {variety="fold"; ancestors=["Loc.fold"]},
  visitors {variety="map"; ancestors=["Loc.fold"]}]

let located_kind = Loc.locate Kind

(* Shift operation for de bruijn ASTs. *)
let shift shift_by =
  let v = 
    object (self) 
      inherit [_] map as super

      method! visit_Type _ = Type 
      method! visit_Kind _ = Kind

      method! visit_Var {data=cutoff; _} index =
        if index >= cutoff then Var (index + shift_by) else Var index 

      method! visit_Pi ({data; _} as cutoff) input_var input_type output_type =
        let input_type = self#visit_expr cutoff input_type in
        let output_type = self#visit_expr (Loc.locate @@ data + 1) output_type in
        Pi {input_var; input_type; output_type}

      method! visit_Fun ({data; _} as cutoff) input_var input_type body =
        let input_type = CCOpt.map (self#visit_expr cutoff) input_type in
        let body = self#visit_expr (Loc.locate @@ data + 1) body in
        Fun {input_var; input_type; body}

      method! visit_App cutoff fn arg =
        let fn = self#visit_expr cutoff fn in
        let arg = self#visit_expr cutoff arg in
        App {fn; arg}

      method! visit_Ascription cutoff expr expr_type =
        let expr = self#visit_expr cutoff expr in
        let expr_type = self#visit_expr cutoff expr_type in
        Ascription {expr; expr_type}
      
      method! visit_Let ({data; _} as cutoff) var_name binding body =
        let binding = self#visit_expr cutoff binding in
        let body = self#visit_expr (Loc.locate @@ data + 1) body in
        Let {var_name; binding; body}

      method! visit_expr cutoff ({data; _} as expr) = 
        data
        |> super#visit_raw_expr cutoff
        |> Loc.set_data expr

      method visit_'a _ _ = located_kind
      method build_located _ _ _ _ = located_kind
  end in v#visit_expr @@ Loc.locate 0

(* let shift shift_by (expr : expr) =
  let rec shift_raw_expr cutoff raw_expr =
    match raw_expr with
    | Type | Kind -> raw_expr

    | Var index as var ->
      if index >= cutoff then Var (index + shift_by) else var

    | Pi {input_var; input_type; output_type} ->
      let input_type = shift_expr cutoff input_type in
      let output_type = shift_expr (cutoff + 1) output_type in
      Pi {input_var; input_type; output_type}

    | Fun {input_var; input_type; body} ->
      let input_type = CCOpt.map (shift_expr cutoff) input_type in
      let body = shift_expr (cutoff + 1) body in
      Fun {input_var; input_type; body}

    | App {fn; arg} ->
      let fn = shift_expr cutoff fn in
      let arg = shift_expr cutoff arg in
      App {fn; arg}

    | Ascription {expr; expr_type} ->
      let expr = shift_expr cutoff expr in
      let expr_type = shift_expr cutoff expr_type in
      Ascription {expr; expr_type}
    
    | Let {var_name; binding; body} ->
      let binding = shift_expr cutoff binding in
      let body = shift_expr (cutoff + 1) body in
      Let {var_name; binding; body}

  and shift_expr cutoff expr =
    Loc.update_data expr @@ shift_raw_expr cutoff

  in shift_expr 0 expr *)

type list_of_exprs = expr list
[@@deriving show]

type stmt = raw_stmt Loc.located
and raw_stmt =
  | Def of {var_name : string; binding : expr}
  | Axiom of {var_name : string; var_type : expr}
  | Check of expr
  | Eval of expr
[@@deriving show]

type list_of_stmts = stmt list
[@@deriving show]