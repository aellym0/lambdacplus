(* This is our internal AST, which is identical to the one generated by the
parser, except that variables are given by de bruijn indices.
*)

type expr = raw_expr Parsing.Location.located
and raw_expr =
  | Type
  | Pi of {input_var : string;
           input_type : expr;
           output_type : expr}
  | Var of int (* This int is the de bruijn index of the variable. *)
  | Fun of {input_var : string;
            body : expr}
  | App of {fn : expr;
            arg : expr}
  | Ascription of {expr : expr;
                   expr_type : expr}
[@@deriving show]

(* Check if 2 expressions are structurally equal. *)
let rec equal (expr1 : expr) (expr2 : expr) =
  match expr1.data, expr2.data with
  | Type, Type -> true

  | Var index1, Var index2 -> index1 = index2 
    (* print_endline @@ "Checking" ^ (string_of_int index1) ^ (string_of_int index2); *)

  | App {fn=fn1; arg=arg1}, App {fn=fn2; arg=arg2} ->
    equal fn1 fn2 && equal arg1 arg2

  | Pi {input_type=in1; output_type=out1; _},
    Pi {input_type=in2; output_type=out2; _} ->
    equal in1 in2 && equal out1 out2

  | Fun {body=body1; _}, Fun {body=body2; _} ->
    equal body1 body2

  | _, _ -> assert false

type list_of_exprs = expr list
[@@deriving show]

type stmt = raw_stmt Parsing.Location.located
and raw_stmt =
  | Def of {var_name : string; binding : expr}
  | Axiom of {var_name : string; var_type : expr}
  | Check of expr
  | Eval of expr
[@@deriving show]

type list_of_stmts = stmt list
[@@deriving show]

let located_type = Parsing.Location.locate Type