(* This is our internal AST, which is identical to the one generated by the
parser, except that variables are given by de bruijn indices.
*)

module Loc = Common.Location

let always_true = fun _ _ -> true

type expr = raw_expr Loc.located
and raw_expr =
  | Type
  | Kind
  | Pi of {input_var : (string [@visitors.opaque] [@equal always_true]);
           input_type : expr;
           output_type : expr}
  | Var of (int [@visitors.opaque])
  | Fun of {input_var : (string [@visitors.opaque] [@equal always_true]);
            input_type : (expr option [@visitors.opaque]);
            body : expr}
  | App of {fn : expr;
            arg : expr}
  | Ascription of {expr : expr;
                   expr_type : expr}
  | Let of {var_name : (string [@visitors.opaque] [@equal always_true]);
            binding : expr;
            body : expr}
[@@deriving show, eq, 
  visitors {variety="map"; ancestors=["Loc.fold"]}]

let located_kind = Loc.locate Kind

(* Template for defining functions that map over the AST while preserving source
   locations. *)
class virtual ['self] ast_mapper =
  object (_ : 'self)
    inherit [_] map as super

    method! visit_expr env ({data; _} as expr) = 
      data
      |> super#visit_raw_expr env
      |> Loc.set_data expr

    (* These are never called. *)
    method visit_'a _ _ = located_kind
    method build_located _ _ _ _ = located_kind
  end

(* Shift operation for de bruijn ASTs. *)
let shift shift_by =
  let v = 
    object (self) 
      inherit [_] ast_mapper

      method! visit_Var {data=cutoff; _} index =
        if index >= cutoff then Var (index + shift_by) else Var index 

      method! visit_Pi cutoff input_var input_type output_type =
        let input_type = self#visit_expr cutoff input_type in
        let output_type = self#visit_expr (self#incr_cutoff cutoff) output_type in
        Pi {input_var; input_type; output_type}

      method! visit_Fun cutoff input_var input_type body =
        let input_type = CCOpt.map (self#visit_expr cutoff) input_type in
        let body = self#visit_expr (self#incr_cutoff cutoff) body in
        Fun {input_var; input_type; body}
      
      method! visit_Let cutoff var_name binding body =
        let binding = self#visit_expr cutoff binding in
        let body = self#visit_expr (self#incr_cutoff cutoff) body in
        Let {var_name; binding; body}

      (* Increment the cutoff. Used whenever we go under a binder. *)
      method incr_cutoff {data=cutoff; _} = Loc.locate @@ cutoff + 1

      (* Note that we don't need to impement the visit_App, visit_Type,
         visit_Kind and visit_Ascription methods since the Visitors package
         automatically handles all that boilerplate for us. *)
  end in v#visit_expr @@ Loc.locate 0

(* let shift shift_by (expr : expr) =
  let rec shift_raw_expr cutoff raw_expr =
    match raw_expr with
    | Type | Kind -> raw_expr

    | Var index as var ->
      if index >= cutoff then Var (index + shift_by) else var

    | Pi {input_var; input_type; output_type} ->
      let input_type = shift_expr cutoff input_type in
      let output_type = shift_expr (cutoff + 1) output_type in
      Pi {input_var; input_type; output_type}

    | Fun {input_var; input_type; body} ->
      let input_type = CCOpt.map (shift_expr cutoff) input_type in
      let body = shift_expr (cutoff + 1) body in
      Fun {input_var; input_type; body}

    | App {fn; arg} ->
      let fn = shift_expr cutoff fn in
      let arg = shift_expr cutoff arg in
      App {fn; arg}

    | Ascription {expr; expr_type} ->
      let expr = shift_expr cutoff expr in
      let expr_type = shift_expr cutoff expr_type in
      Ascription {expr; expr_type}
    
    | Let {var_name; binding; body} ->
      let binding = shift_expr cutoff binding in
      let body = shift_expr (cutoff + 1) body in
      Let {var_name; binding; body}

  and shift_expr cutoff expr =
    Loc.update_data expr @@ shift_raw_expr cutoff

  in shift_expr 0 expr *)

type list_of_exprs = expr list
[@@deriving show]

type stmt = raw_stmt Loc.located
and raw_stmt =
  | Def of {var_name : string; binding : expr}
  | Axiom of {var_name : string; var_type : expr}
  | Check of expr
  | Eval of expr
[@@deriving show]

type list_of_stmts = stmt list
[@@deriving show]