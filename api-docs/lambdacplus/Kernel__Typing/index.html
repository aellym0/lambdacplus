<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Kernel__Typing (lambdacplus.Kernel__Typing)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">lambdacplus</a> &#x00BB; Kernel__Typing</nav><h1>Module <code>Kernel__Typing</code></h1><p>This module implements the bidirectional typing judgments as described in the semantic specification.</p><p>In particular,</p><ul><li><a href="index.html#val-infer"><code>infer</code></a> corresponds to the judgment Γ ⊦ E ⇒ τ</li><li><a href="index.html#val-check"><code>check</code></a> corresponds to the judgment Γ ⊦ E ⇐ τ</li></ul><p>Technically we implement these functions to take some extra parameters for the purposes of error reporting.</p><p>This module also defines some type related exceptions that can arise when type checking input from the user. These are used by <a href="../Lambdacplus/Error_reporting/index.html"><code>Error_reporting</code></a> to format errors to report to the user.</p></header><dl><dt class="spec type" id="type-expr_with_ctx"><a href="#type-expr_with_ctx" class="anchor"></a><code><span class="keyword">type</span> expr_with_ctx</code><code> = </code><code>{</code><table class="record"><tr id="type-expr_with_ctx.expr" class="anchored"><td class="def field"><a href="#type-expr_with_ctx.expr" class="anchor"></a><code>expr : <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span>;</code></td><td class="doc"><p>The expression that gave an error while typechecking.</p></td></tr><tr id="type-expr_with_ctx.ctx" class="anchored"><td class="def field"><a href="#type-expr_with_ctx.ctx" class="anchor"></a><code>ctx : <a href="../Kernel/Context/index.html#type-t">Kernel.Context.t</a>;</code></td><td class="doc"><p>The evaluation context at the point when <a href="index.html#type-expr_with_ctx.expr"><code>expr</code></a> was encountered.</p></td></tr></table><code>}</code></dt><dd><p>Used to store expressions along with a context. This is contained inn exceptions that we raise when we encounter typing errors.</p></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <span>outer_expr:<span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span></span> <span>&#45;&gt;</span> <a href="../Kernel/Context/index.html#type-t">Kernel.Context.t</a> <span>&#45;&gt;</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span> <span>&#45;&gt;</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>check ~outer_expr ctx expr expected_type</code> checks if expr has the type <code>expected_type</code> with respect to <code>ctx</code>.</p><p>This function throws a <a href="index.html#exception-Type_mismatch"><code>Type_mismatch</code></a> exception if something goes wrong, otherwise it just returns ().</p><p>The <code>outer_expr</code> argument is used in the creation of the <a href="index.html#exception-Type_mismatch"><code>Type_mismatch</code></a> exception should anything go wrong. This is used to provide contextual information for error reporting.</p></dd></dl><dl><dt class="spec type" id="type-expected_type"><a href="#type-expected_type" class="anchor"></a><code><span class="keyword">type</span> expected_type</code><code> = </code><table class="variant"><tr id="type-expected_type.Exact" class="anchored"><td class="def constructor"><a href="#type-expected_type.Exact" class="anchor"></a><code>| </code><code><span class="constructor">Exact</span> <span class="keyword">of</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span></code></td></tr><tr id="type-expected_type.Family" class="anchored"><td class="def constructor"><a href="#type-expected_type.Family" class="anchor"></a><code>| </code><code><span class="constructor">Family</span> <span class="keyword">of</span> string</code></td></tr></table></dt><dd><p>This is only used in <a href="index.html#exception-Type_mismatch"><code>Type_mismatch</code></a> exceptions. See below for details.</p></dd></dl><dl><dt class="spec exception" id="exception-Type_mismatch"><a href="#exception-Type_mismatch" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Type_mismatch</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id=".outer_expr" class="anchored"><td class="def field"><a href="#.outer_expr" class="anchor"></a><code>outer_expr : <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span>;</code></td></tr><tr id=".expr" class="anchored"><td class="def field"><a href="#.expr" class="anchor"></a><code>expr : <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span>;</code></td></tr><tr id=".inferred_type" class="anchored"><td class="def field"><a href="#.inferred_type" class="anchor"></a><code>inferred_type : <a href="index.html#type-expr_with_ctx">expr_with_ctx</a>;</code></td></tr><tr id=".expected_type" class="anchored"><td class="def field"><a href="#.expected_type" class="anchor"></a><code>expected_type : <a href="index.html#type-expected_type">expected_type</a>;</code></td></tr></table><code>}</code></dt><dd><p>This is read as:</p><p>While typechecking <code>outer_expr</code>, we found that <a href="index.html#type-expr_with_ctx.expr"><code>expr</code></a> has the type <code>inferred_type</code> but it was expected to have <a href="index.html#type-expected_type"><code>expected_type</code></a>.</p><p>Note that there are 2 cases to `expected_type`. It can either be a concrete type, in the event that the user supplied that type in the form of an annotation. Otherwise, if we don't know precisely what type it is, we give a string indicating what family it should belong to. For instance, when we're typing checking a function application, we expect the function expression to be of some Pi type, though we may not know precisely what the exact form is.</p></dd></dl><dl><dt class="spec exception" id="exception-Type_mismatch_in_match"><a href="#exception-Type_mismatch_in_match" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Type_mismatch_in_match</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id=".outer_expr" class="anchored"><td class="def field"><a href="#.outer_expr" class="anchor"></a><code>outer_expr : <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span>;</code></td></tr><tr id=".inl_type" class="anchored"><td class="def field"><a href="#.inl_type" class="anchor"></a><code>inl_type : <a href="index.html#type-expr_with_ctx">expr_with_ctx</a>;</code></td></tr><tr id=".inr_type" class="anchored"><td class="def field"><a href="#.inr_type" class="anchor"></a><code>inr_type : <a href="index.html#type-expr_with_ctx">expr_with_ctx</a>;</code></td></tr></table><code>}</code></dt><dt class="spec exception" id="exception-Type_contains_free_var"><a href="#exception-Type_contains_free_var" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Type_contains_free_var</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id=".outer_expr" class="anchored"><td class="def field"><a href="#.outer_expr" class="anchor"></a><code>outer_expr : <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span>;</code></td></tr><tr id=".inferred_type" class="anchored"><td class="def field"><a href="#.inferred_type" class="anchor"></a><code>inferred_type : <a href="index.html#type-expr_with_ctx">expr_with_ctx</a>;</code></td></tr><tr id=".free_var" class="anchored"><td class="def field"><a href="#.free_var" class="anchor"></a><code>free_var : string;</code></td></tr></table><code>}</code></dt><dd><p>Read as: While typechecking <code>outer_expr</code> (which is an existential elimination of the form let {x, y} := E in E'), we found that the inferred type of E', <code>inferred_type</code>, contains <code>free_var</code> free in it.</p><p>Remember that the variable introduced into the context for the witness cannot appear free in the conclusion.</p></dd></dl><dl><dt class="spec value" id="val-infer"><a href="#val-infer" class="anchor"></a><code><span class="keyword">val</span> infer : <a href="../Kernel/Context/index.html#type-t">Kernel.Context.t</a> <span>&#45;&gt;</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span> <span>&#45;&gt;</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span></code></dt><dd><p><code>infer ctx expr</code> tries to compute the type of <code>expr</code> with respect to <code>ctx</code>.</p><p>A <a href="index.html#exception-Cannot_infer_type"><code>Cannot_infer_type</code></a> exception is thrown if we have insufficient information to compute the type.</p></dd></dl><dl><dt class="spec value" id="val-infer_annotation"><a href="#val-infer_annotation" class="anchor"></a><code><span class="keyword">val</span> infer_annotation : <span>outer_expr:<span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span></span> <span>&#45;&gt;</span> <a href="../Kernel/Context/index.html#type-t">Kernel.Context.t</a> <span>&#45;&gt;</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span> <span>&#45;&gt;</span> <span><span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span> option</span> <span>&#45;&gt;</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span></code></dt><dd><p><code>infer_annotation ~outer_expr ctx expr ascribed_type</code> implements the typing judgment for type ascriptions.</p><p>If <code>ascribed_type</code> is <code>Some</code>, check that it's well formed and that <code>expr</code> has that type. Otherwise, try to <a href="index.html#val-infer"><code>infer</code></a> the type of <code>expr</code> from <code>ctx</code> directly. If all goes well, a normalized form of the inferred type is returned. Otherwise, an exception is thrown.</p></dd></dl><dl><dt class="spec exception" id="exception-Cannot_infer_type"><a href="#exception-Cannot_infer_type" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Cannot_infer_type</span> <span class="keyword">of</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span></code></dt><dd><p>This is thrown by <a href="index.html#val-infer"><code>infer</code></a> if we're unable to infer the type of <code>expr</code>.</p></dd></dl><dl><dt class="spec value" id="val-check_well_formed_type"><a href="#val-check_well_formed_type" class="anchor"></a><code><span class="keyword">val</span> check_well_formed_type : <a href="../Kernel/Context/index.html#type-t">Kernel.Context.t</a> <span>&#45;&gt;</span> <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>check_well_formed_type ctx expr</code> checks if <code>expr</code> is a well formed type (ie it has type <code>Type</code> or <code>Kind</code>) wrt to <code>ctx</code>.</p><p>If all goes well, () is returned. Otherwise, <a href="index.html#exception-Ill_formed_type"><code>Ill_formed_type</code></a> is thrown.</p></dd></dl><dl><dt class="spec exception" id="exception-Ill_formed_type"><a href="#exception-Ill_formed_type" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Ill_formed_type</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id=".expr" class="anchored"><td class="def field"><a href="#.expr" class="anchor"></a><code>expr : <span>int <a href="../Common/Ast/index.html#type-expr">Common.Ast.expr</a></span>;</code></td></tr><tr id=".inferred_type" class="anchored"><td class="def field"><a href="#.inferred_type" class="anchor"></a><code>inferred_type : <a href="index.html#type-expr_with_ctx">expr_with_ctx</a>;</code></td></tr></table><code>}</code></dt><dd><p>Read as: <code>expr</code> is not a well formed type because we inferred its type to be <code>inferred_type</code>, but it should be <code>Type</code> or <code>Kind</code> instead.</p></dd></dl></div></body></html>