# cs4215_dependent_types
CS4215 project on dependent types

## Usage
This section is heavily based on [this example](https://github.com/esy-ocaml/hello-ocaml).

First you need to install [Esy](https://esy.sh/en/) using your distro's native
package manager or via:
```console
% npm install -g esy
```

Esy is a package manager for Ocaml and Reason. It helps manage project
dependencies via `package.json`.

To install all the required dependencies and build the project with a single
command, you may run
```console
% esy
```

If you just want to install the dependencies without building, use
```console
% esy install
```

To build the package, use
```console
% esy build
```

To run the compiled executable:
```console
% esy ./_esy/default/build/default/bin/main.bc
```

To run the compiled js:
```console
% esy ./_esy/default/build/default/bin/main.bc.js
```

## Overview of this branch
This branch is for testing an implementation of de Bruijn indices.

Following Spartan tt, we now have 2 layers of AST, namely:
1. the parser's AST, in lib/syntax/parsing/ast.ml
2. the internal AST, in lib/syntax/internal/ast.ml

The former is generated by the parser, and uses strings for variable names,
while the latter uses de Bruijn indices for variables. Note that the AST at this
point is still untyped, ie it hasn't been type checked yet.

The `debruijn.ml` module defines a naming context datatype and an API for
manipulating it. This datatype is used for book-keeping purposes, when converting
variable names to indices and vice versa.

Currently the naming context only handles conversion between de brujin indices
and variable names. It doesn't carry any information about the type or binding
of the variable. This is in line with Spartan tt's approach, which uses separate
contexts and phases for type checking and printing.

The module also contains functions for converting between both ASTs. Most
prominent are:
1. `parser_to_internal_expr`
2. `parser_to_intenal_stmt` 
3. `parser_to_intenal_stmts` 
4. `internal_to_parser_expr`

The first 3 are useful for converting from the parser's AST to our internal one,
while the fourth converts the other way around for printing purposes.
Note that (2) and (3) not only return the converted statement(s) but also the
new context resulting from processing a new variable.

The implementation for these functions is heavily inspired by Spartan tt and
the `Types and Programming Languages` book.

## Future directions
We have 2 ways we can proceed from here.

### Separate printing and typing + binding contexts
The first is to follow Spartan tt and implement separate phases and contexts for
printing and type checking. In this approach, we would have a naming context
and another context carrying binding and typing information.
At the top level, we first construct 2 such contexts, both of which are initially
empty. Whenever a user enters a statement, we do the following:
- Convert the input to our internal AST.
- Next we ignore the naming context and proceed to use the typing + binding context
and step through the statement to typecheck it.

This means that whenever the user enters a statement, we will get a new naming
context and typing + binding context, which we carry along to process the next
statement that is entered.

### Same printing and typing + binding contexts
The second approach is the one is adopted by the `Types and Programming Languages`
book.

TODO: Research more on this approach and compare the differences between both.
