# CS4215 dependent types
## Overview
CS4215 project on dependent types.
This is a strongly normalizing lambda calculus with dependent types.
The main focus is to implement the dependent Pi type, which generalizes the
simple function type.

## Project structure
- `bin` is where all the driver code for the compiled
executable can be found. Currently it only contains `main.ml`, which we are
using for testing and experimentation.
- `lib` is our library which contains all the code making our language work.
    - `parsing` contains all the functions we use for parsing.
        - `ast.ml` contains the AST generated by the parser. This uses strings
        to identify variables.
        - `lexer.ml` contains our lexer.
        - `grammar.mly` contains our grammar, written using Menhir.
        - `parser.ml` contains some functions and boilerplate code tying the
        lexer and grammar together. This provides an interface which we use to
        parse our language.
        - `location.ml` contains a `located` datatype and other stuff which we use
        to decorate our ASTs as found in `lib/parsing/ast.ml` and 
        `lib/kernel/ast.ml` with source locations. This info will be used for
        error reporting.
    - `kernel` contains all the important stuff, like normalization and type
    checking. Basically everything that happens after parsing can be found here.
        - `ast.ml` contains our internal AST. Unlike the one in `lib/parsing`,
        this uses de bruijn indices for variables, rather than strings.
        - `context.ml` is the module implementing the context/environment.
        The level of abstraction is controlled via the module signature found in
        `context.mli`.
        This functions like a list of triples of triples of the form
                (var name string, type of var, binding)
        - `normalization.ml` currently contains the `shift` and `subst`
        functions for working with our AST using de bruijn indices.
        We aim to implement the `normalize` function for expressions soon.
        - `typing.ml` is currently empty. Eventually we will implement our
        bidirectional typechecking algorithm here.
        This will include the 2 key functions `check` and `infer`, where `infer`
        involves synthesizing the type, while `check` involves verifying if an
        expression has a given type.
        - `debruijn.ml` contains facilities for converting the parser's AST to 
        the internal AST and vice versa. For an overview of the key functions,
        refer to its module signature, `debruijn.mli`.
    - `utils` contains utilities used in all parts of the project.

## Usage
This section is heavily based on [this example](https://github.com/esy-ocaml/hello-ocaml).

First you need to install [Esy](https://esy.sh/en/) using your distro's native
package manager or via:
```console
% npm install -g esy
```

Esy is a package manager for Ocaml and Reason. It helps manage project
dependencies via `package.json`.

To install all the required dependencies and build the project with a single
command, you may run
```shell
$ esy
```

If you just want to install the dependencies without building, use
```shell
$ esy install
```

To build the package, use
```shell
$ esy build
```

To run the compiled executable:
```shell
$ esy ./_esy/default/build/default/bin/main.bc
```

To run the compiled js:
```shell
$ esy ./_esy/default/build/default/bin/main.bc.js
```

A sample run is as follows:
Note that pretty printing for source locations, given by the `source_loc` field
has yet to be implemented, so those appear blank here.
```shell
$ ./run_main.sh
Enter input for parsing:
axiom T : Type
def f := (fun x => x : Pi (x : T), T)

Parser AST:
[{ Location.data =
   Ast.Axiom {var_name = "T";
     var_type = { Location.data = Ast.Type; source_loc =  }};
   source_loc =  };
  { Location.data =
    Ast.Def {var_name = "f";
      var_expr =
      { Location.data =
        Ast.Ascription {
          expr =
          { Location.data =
            Ast.Fun {input_var = "x";
              body = { Location.data = (Ast.Var "x"); source_loc =  }};
            source_loc =  };
          expr_type =
          { Location.data =
            Ast.Pi {input_var = "x";
              input_type = { Location.data = (Ast.Var "T"); source_loc =  };
              output_type = { Location.data = (Ast.Var "T"); source_loc =  }};
            source_loc =  }};
        source_loc =  }};
    source_loc =  }
  ]

De Bruijn AST:
[{ Location.data =
   Ast.Axiom {var_name = "T";
     var_type = { Location.data = Ast.Type; source_loc =  }};
   source_loc =  };
  { Location.data =
    Ast.Def {var_name = "f";
      var_expr =
      { Location.data =
        Ast.Ascription {
          expr =
          { Location.data =
            Ast.Fun {input_var = "x";
              body = { Location.data = (Ast.Var 0); source_loc =  }};
            source_loc =  };
          expr_type =
          { Location.data =
            Ast.Pi {input_var = "x";
              input_type = { Location.data = (Ast.Var 0); source_loc =  };
              output_type = { Location.data = (Ast.Var 1); source_loc =  }};
            source_loc =  }};
        source_loc =  }};
    source_loc =  }
  ]

Final context:
[{ Context.Context.var_name = "f"; var_type = None; binding = None }; { Context.Context.var_name = "T"; var_type = None; binding = None }]

Parsing last expr back to parser's AST:
{ Location.data =
  Ast.Ascription {
    expr =
    { Location.data =
      Ast.Fun {input_var = "x";
        body = { Location.data = (Ast.Var "x"); source_loc =  }};
      source_loc =  };
    expr_type =
    { Location.data =
      Ast.Pi {input_var = "x";
        input_type = { Location.data = (Ast.Var "f"); source_loc =  };
        output_type = { Location.data = (Ast.Var "f"); source_loc =  }};
      source_loc =  }};
  source_loc =  }
```
