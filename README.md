# CS4215 dependent types
## Overview
This is a dependently typed lambda calculus based on the pure type system (PTS)
that is the Calculus of Constructions (CC).
Like all the other PTSes in Barendregt's lambda cube, CC is strongly normalizing
and serves as a consistent foundation for theorem proving in higher order
intuitionistic logic.

### Specs
Refer to the `latex` directory.

## Usage
This section is heavily based on [this example](https://github.com/esy-ocaml/hello-ocaml).

First you need to install [Esy](https://esy.sh/en/) using your distro's native
package manager or via:
```console
% npm install -g esy
```

Esy is a package manager for Ocaml and Reason. It helps manage project
dependencies via `package.json`.

To install all the required dependencies and build the project with a single
command, you may run
```shell
$ esy
```

If you just want to install the dependencies without building, use
```shell
$ esy install
```

To build the package, use
```shell
$ esy build
```

To run the compiled executable:
```shell
$ esy ./_esy/default/build/default/bin/main.bc
```

To run the compiled js:
```shell
$ esy ./_esy/default/build/default/bin/main.bc.js
```

To ease testing, the `run_main.sh` script has been provided with the command
`esy ./_esy/default/build/default/bin/main.bc`.

## Sample execution
```shell
$ ./run_main.sh
// Assume that T is a type and that P is some unary predicate.
constant T : Type
constant P : ∏ (_ : T), Prop

// Further assume that the predicate P holds for every x of type T.
// This behaves like a lambda abstraction that returns a proof of (P x) for
// any input x of type T.
axiom ax : ∀ (x : T), P x

// Now suppose y is an element of type T.
constant y : T

// hPy is a proof that (P y) holds.
def hPy := (ax y : P y)

// Let's try to normalize a funny looking expression.
eval let id := λ (T : Type) (x : T) => x in id (P y) hPy

Here's the output:
(ax y)
```

More sample programs can be found in the `sample_programs` directory.

## Current status
### What seems to work
- Normalization
- Context
- Type checking and inference

### What needs working on
- Practical side
  - More testing
  -  [x] Better error reporting and error messages
  - [x] Better pretty printing
  - [ ] Glue code for tying everything together
  - [ ]REPL environment
  - [ ] Tie our code into Typescript frontend

- Theory side
  - Add new types:
    - [ ] Sigma aka existential quantifier
    - [ ] Binary product aka conjunction
    - [ ] Binary coproduct aka disjunction
    - [ ] Unit, aka the singleton type, aka logical truth
    - [ ] Void, aka the empty type, aka logical falsity

using for testing and experimentation.
- `lib` is our library which contains all the code making our language work.
    - `parsing` contains all the functions we use for parsing.
        - `ast.ml` contains the AST generated by the parser. This uses strings
        to identify variables. There are some helper functions for manipulating
        the AST and unparsing expressions back to string for printing.
        - `lexer.ml` contains our lexer.
        - `grammar.mly` contains our grammar, written using Menhir.
        - `parser.ml` contains some functions and boilerplate code tying the
        lexer and grammar together. This provides an interface which we use to
        parse our language.
    - `kernel` contains all the important stuff for evaluating expressions and
    statements. These include normalization, type checking and context management
    using de bruijn indices.
        - `ast.ml` contains our internal AST. Unlike the one in `lib/parsing`,
        this uses de bruijn indices for variables, rather than strings. It also
        has some utilities, like for comparing equality of beta normal forms.
        - `context.ml` is the module implementing the context/environment.
        The level of abstraction is controlled via the module signature found in
        `context.mli`.
        Contexts function like a list of triples of triples of the form
                (var name string, type of var, binding)
        - `normalization.ml` currently contains the `shift` and `subst`
        functions for working with our AST using de bruijn indices.
        We aim to implement the `normalize` function for expressions soon.
        - `typing.ml` is currently empty. Eventually we will implement our
        bidirectional typechecking algorithm here.
        This will include the 2 key functions `check` and `infer`, where `infer`
        involves synthesizing the type, while `check` involves verifying if an
        expression has a given type.
        - `eval_statements.ml` contains functions for evaluating statements.
    - `common` contains code that is shared between both `kernel` and `parsing`.
       - `location.ml` contains a `located` datatype and other stuff which we use
       to decorate our ASTs as found in `lib/parsing/ast.ml` and 
       `lib/kernel/ast.ml` with source locations. This info will be used for
       error reporting.
   - `ast_conv.ml` contains facilities for converting the parser's AST to 
   the internal AST and vice versa.
   - `error_reporting.ml` contains functions for handling errors that occur while
   running programs in our language. These include pretty printing of errors.